<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>STICKMAN SOUL - START OPTIMIZED</title>
    <style>
        :root { --blue: #00f2ff; --red: #ff0044; --gold: #ffcc00; --block: #55ff55; }
        * { user-select: none; -webkit-tap-highlight-color: transparent; touch-action: none; }
        body { background: #000; color: white; margin: 0; overflow: hidden; font-family: 'Arial Black', sans-serif; }
        
        #hud { position: absolute; width: 100%; top: 20px; display: flex; justify-content: space-around; z-index: 10; pointer-events: none; }
        .stat-box { width: 35%; }
        .bar-bg { background: #222; height: 18px; border: 2px solid #444; transform: skewX(-15deg); overflow: hidden; }
        .fill { height: 100%; width: 100%; transition: width 0.1s; }
        #p1-hp { background: linear-gradient(90deg, #0055ff, var(--blue)); box-shadow: 0 0 10px var(--blue); }
        #p2-hp { background: linear-gradient(90deg, #aa0000, var(--red)); box-shadow: 0 0 10px var(--red); }
        
        #combo-container { 
            position: absolute; left: 50px; top: 120px; color: var(--gold); 
            font-size: 50px; font-style: italic; text-shadow: 0 0 20px rgba(255,204,0,0.8);
            opacity: 0; transform: translateX(-20px); transition: all 0.2s; pointer-events: none;
        }
        .combo-active { opacity: 1 !important; transform: translateX(0) !important; }

        canvas { display: block; background: #050505; margin: 0 auto; max-width: 100vw; }
        
        /* 啟動選單樣式 */
        #overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; text-align: center; }
        #start-btn { 
            margin-top: 20px; padding: 15px 40px; font-size: 24px; color: white; 
            background: transparent; border: 3px solid var(--blue); border-radius: 50px;
            cursor: pointer; box-shadow: 0 0 15px var(--blue); transition: 0.2s;
        }
        #start-btn:active { background: var(--blue); color: black; transform: scale(0.95); }

        .controls { position: fixed; bottom: 20px; width: 100%; display: flex; justify-content: space-between; padding: 0 15px; box-sizing: border-box; }
        .btn-group { display: flex; gap: 8px; }
        .btn { width: 60px; height: 60px; background: rgba(255,255,255,0.15); border: 2px solid #666; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 20px; color: white; }
    </style>
</head>
<body>

<div id="hud">
    <div class="stat-box">
        <div class="bar-bg"><div id="p1-hp" class="fill"></div></div>
        <div style="height:6px; background:#111; margin-top:5px; transform:skewX(-15deg);"><div id="p1-en" class="fill" style="background:var(--gold); width:0%;"></div></div>
    </div>
    <div id="stage-text" style="color: var(--gold); font-size: 24px;">STAGE 1</div>
    <div class="stat-box"><div class="bar-bg"><div id="p2-hp" class="fill"></div></div></div>
</div>

<div id="combo-container"><span id="combo-count">0</span><br><small style="font-size:18px">COMBO</small></div>

<canvas id="game" width="800" height="400"></canvas>

<div id="overlay">
    <h1 id="msg-h" style="color: var(--blue); font-size: 60px; margin: 0; text-shadow: 0 0 20px var(--blue);">STICKMAN SOUL</h1>
    <p id="msg-p" style="font-size: 18px; color: #aaa; margin: 10px 0;">[PC] PRESS SPACE | [MOBILE] TAP START</p>
    <button id="start-btn" onclick="handleStart()">START GAME</button>
</div>

<div class="controls">
    <div class="btn-group">
        <div class="btn" id="btn-A">A</div>
        <div class="btn" id="btn-D">D</div>
        <div class="btn" id="btn-W">W</div>
    </div>
    <div class="btn-group">
        <div class="btn" id="btn-J">J</div>
        <div class="btn" id="btn-K" style="color:var(--gold); border-color:var(--gold);">K</div>
    </div>
</div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const COLORS = { blue: '#00f2ff', red: '#ff0044', gold: '#ffcc00', block: '#55ff55' };

let gameState = 'MENU';
let currentStage = 1;
let shake = 0;
let combo = 0;
const keys = { a: false, d: false };

// --- 集中啟動函數 ---
function handleStart() {
    if (gameState === 'PLAYING') return;
    startGame();
}

class Fighter {
    constructor(x, color, isP) {
        this.isP = isP; this.color = color; this.size = 1; this.reset(x);
    }
    reset(x) {
        this.x = x; this.y = 300; this.hp = 100; this.en = 0;
        this.dx = 0; this.dy = 0; this.stun = 0; this.atkAnim = 0; this.atkCD = 0; this.ultAnim = 0;
        this.blocking = false; this.blockEffect = 0; this.dead = false; this.opacity = 1;
        this.dir = this.isP ? 1 : -1; this.jumping = false; this.maxHp = 100;
        this.isAerialAtk = false;
    }
    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.scale(this.size, this.size);
        ctx.globalAlpha = this.opacity;
        
        if (this.blockEffect > 0) {
            ctx.beginPath();
            ctx.strokeStyle = `rgba(85, 255, 85, ${this.blockEffect/10})`;
            ctx.lineWidth = 2;
            ctx.arc(0, -20, 40 - this.blockEffect*2, 0, Math.PI*2);
            ctx.stroke();
            this.blockEffect--;
        }

        let drawColor = (this.stun > 0) ? '#fff' : (this.blocking ? COLORS.block : (this.ultAnim > 20 ? '#fff' : this.color));
        ctx.strokeStyle = drawColor; ctx.lineWidth = 5; ctx.lineCap = 'round';

        let angle = 0;
        if (this.dead) angle = Math.PI/2 * this.dir;
        else if (this.stun > 0) angle = -0.2 * this.dir;
        ctx.rotate(angle);

        ctx.beginPath(); ctx.arc(0, -40, 10, 0, 7); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, -30); ctx.lineTo(0, 0); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(this.blocking?-8:-12, 20); ctx.moveTo(0,0); ctx.lineTo(this.blocking?8:12, 20); ctx.stroke();

        ctx.beginPath();
        if (this.blocking) {
            ctx.moveTo(10*this.dir, -35); ctx.lineTo(5*this.dir, -15);
            ctx.moveTo(12*this.dir, -30); ctx.lineTo(2*this.dir, -10);
        } else if (this.ultAnim > 0) {
            ctx.moveTo(-10*this.dir, -25); ctx.lineTo(45*this.dir, this.isAerialAtk ? 10 : -30);
            if (this.ultAnim < 25) {
                ctx.save();
                if (this.isAerialAtk) ctx.rotate(0.5 * this.dir);
                let g = ctx.createLinearGradient(0, -25, 600*this.dir, -25);
                g.addColorStop(0, '#fff'); g.addColorStop(0.3, this.color); g.addColorStop(1, 'transparent');
                ctx.fillStyle = g; ctx.fillRect(10*this.dir, -55, 600*this.dir, 60);
                ctx.restore();
            }
        } else if (this.atkAnim > 0) {
            ctx.moveTo(-5*this.dir, -25); ctx.lineTo(50*this.dir, this.jumping ? 10 : -25);
        } else {
            ctx.moveTo(0, -20); ctx.lineTo(15*this.dir, -10);
        }
        ctx.stroke();
        ctx.restore();
    }
    update(opp) {
        if (this.dead) { this.opacity -= 0.02; return; }
        if (this.stun > 0) this.stun--;
        if (this.atkAnim > 0) this.atkAnim--;
        if (this.atkCD > 0) this.atkCD--;
        if (this.ultAnim > 0) this.ultAnim--;

        let dist = opp.x - this.x;
        this.dir = dist > 0 ? 1 : -1;

        if (this.stun > 0) {
            this.dx *= 0.85; this.blocking = false;
        } else if (this.ultAnim > 25) {
            this.dx = 0;
        } else if (this.isP) {
            this.blocking = (keys.a && this.dir === 1) || (keys.d && this.dir === -1);
            if (keys.a) this.dx = -5; else if (keys.d) this.dx = 5; else this.dx = 0;
        } else {
            let moveSpeed = 2.5 + currentStage * 0.5;
            if (!this.jumping && Math.abs(dist) < 180 && Math.random() < 0.015) { this.dy = -15; this.jumping = true; }
            this.blocking = (opp.atkAnim > 0 && Math.abs(dist) < 110 && Math.random() < 0.4 + (currentStage*0.1));
            if (!this.blocking) {
                if (Math.abs(dist) > 80 * this.size) this.dx = (dist > 0 ? 1 : -1) * moveSpeed;
                else { this.dx = 0; if (this.atkCD <= 0 && Math.random() < 0.1) attack(this, opp, false); }
            } else { this.dx = (dist > 0 ? -1 : 1) * 2; }
            if (this.en >= 100 && Math.abs(dist) < 300) { this.en = 0; attack(this, opp, true); }
        }

        this.dy += 0.8; this.x += this.dx; this.y += this.dy;
        if (this.y > 300) { this.y = 300; this.dy = 0; this.jumping = false; this.isAerialAtk = false; }
        this.x = Math.max(30, Math.min(770, this.x));
    }
}

let p1 = new Fighter(150, COLORS.blue, true);
let ai = new Fighter(650, COLORS.red, false);

function attack(a, t, ultra) {
    if (gameState !== 'PLAYING' || a.stun > 0 || a.dead) return;
    a.isAerialAtk = a.jumping;
    if (ultra) {
        a.ultAnim = 40;
        setTimeout(() => applyDamage(a, t, true, a.isAerialAtk), 200);
    } else {
        if (a.atkCD > 0) return;
        a.atkAnim = 12; a.atkCD = 28;
        if (a.jumping) { a.dy = 12; a.dx = a.dir * 10; }
        applyDamage(a, t, false, a.isAerialAtk);
    }
}

function applyDamage(a, t, ultra, isAir) {
    let range = (ultra ? 600 : 105) * a.size;
    let hit = Math.abs(a.x - t.x) < range && ((a.dir === 1 && t.x > a.x) || (a.dir === -1 && t.x < a.x));
    if (hit) {
        if (t.blocking && !ultra) { 
            t.hp -= 2; t.en = Math.min(100, t.en + 25); t.blockEffect = 10; shake = 2;
        } else {
            t.hp -= ultra ? 25 : (isAir ? 18 : 12);
            t.stun = ultra ? 45 : (isAir ? 32 : 22);
            t.dx = a.dir * (ultra ? 35 : (isAir ? 25 : 18));
            t.dy = ultra ? -12 : (isAir ? 6 : -5);
            a.en = Math.min(100, a.en + 20); shake = ultra ? 25 : 12;
            if (a.isP) { combo++; updateComboUI(); } 
            else if (t.isP) { combo = 0; updateComboUI(); }
        }
        if (t.hp <= 0) t.dead = true;
    }
}

function updateComboUI() {
    const el = document.getElementById('combo-container');
    document.getElementById('combo-count').innerText = combo;
    if (combo > 0) el.classList.add('combo-active'); else el.classList.remove('combo-active');
}

function startGame() {
    if (gameState !== 'WON') currentStage = (gameState === 'LOST' || gameState === 'FINISHED') ? 1 : currentStage;
    if (gameState === 'LOST' || gameState === 'FINISHED') combo = 0;
    p1.reset(150);
    ai.size = currentStage === 5 ? 1.8 : 1;
    ai.maxHp = currentStage === 5 ? 400 : (100 + currentStage * 40);
    ai.reset(650); ai.hp = ai.maxHp;
    document.getElementById('overlay').style.display = 'none';
    document.getElementById('stage-text').innerText = currentStage === 5 ? "FINAL BOSS" : "STAGE " + currentStage;
    gameState = 'PLAYING';
    updateComboUI();
}

// --- 監聽電腦空格鍵 ---
window.addEventListener('keydown', e => {
    if (e.code === 'Space') {
        e.preventDefault();
        handleStart();
        return;
    }
    if (gameState !== 'PLAYING') return;
    const k = e.key.toLowerCase();
    if (k === 'a') keys.a = true; if (k === 'd') keys.d = true;
    if (k === 'w' && !p1.jumping) { p1.dy = -17; p1.jumping = true; }
    if (k === 'j') attack(p1, ai, false);
    if (k === 'k' && p1.en >= 100) { p1.en = 0; attack(p1, ai, true); }
});
window.addEventListener('keyup', e => {
    const k = e.key.toLowerCase();
    if (k === 'a') keys.a = false; if (k === 'd') keys.d = false;
});

// --- 手機按鈕監聽 ---
function bindBtn(id, action) {
    const el = document.getElementById(id);
    el.addEventListener('touchstart', (e) => { 
        e.preventDefault(); 
        if(gameState !== 'PLAYING') handleStart(); 
        else action(true); 
    });
    el.addEventListener('touchend', (e) => { e.preventDefault(); action(false); });
}
bindBtn('btn-A', v => keys.a = v); bindBtn('btn-D', v => keys.d = v); 
bindBtn('btn-W', v => { if(v && !p1.jumping && gameState === 'PLAYING') { p1.dy = -17; p1.jumping = true; }});
bindBtn('btn-J', v => { if(v && gameState === 'PLAYING') attack(p1, ai, false); });
bindBtn('btn-K', v => { if(v && p1.en >= 100 && gameState === 'PLAYING') { p1.en = 0; attack(p1, ai, true); }});

function loop() {
    ctx.clearRect(0,0,800,400);
    ctx.save();
    if (shake > 0) { ctx.translate(Math.random()*shake-shake/2, Math.random()*shake-shake/2); shake *= 0.9; }
    ctx.strokeStyle = '#333'; ctx.beginPath(); ctx.moveTo(0,320); ctx.lineTo(800,320); ctx.stroke();
    if (gameState === 'PLAYING') {
        p1.update(ai); ai.update(p1);
        if (ai.dead && ai.opacity <= 0) {
            if (currentStage < 5) { currentStage++; gameState = 'WON'; document.getElementById('overlay').style.display = 'flex'; document.getElementById('msg-h').innerText = "STAGE CLEAR"; document.getElementById('msg-p').innerText = "PRESS SPACE OR TAP START"; }
            else { gameState = 'FINISHED'; document.getElementById('overlay').style.display = 'flex'; document.getElementById('msg-h').innerText = "GODLIKE!"; document.getElementById('msg-p').innerText = "TAP START TO RESET"; }
        }
        if (p1.dead && p1.opacity <= 0) { gameState = 'LOST'; document.getElementById('overlay').style.display = 'flex'; document.getElementById('msg-h').innerText = "DEFEATED"; document.getElementById('msg-p').innerText = "DON'T GIVE UP!"; }
    }
    p1.draw(); ai.draw();
    ctx.restore();
    document.getElementById('p1-hp').style.width = Math.max(0, p1.hp) + '%';
    document.getElementById('p2-hp').style.width = Math.max(0, (ai.hp/ai.maxHp*100)) + '%';
    document.getElementById('p1-en').style.width = p1.en + '%';
    requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
